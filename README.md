# Welcome to another, another C++ build system

<img src="https://raw.githubusercontent.com/podusowski/pake/master/screenshot.png" />

(example of pake script which does some more things like db generation, see more at (rusted)[https://github.com/podusowski/rusted])

## What is the difference?
The main difference is that pake's script does not allow any logic, it means, you can not make conditions, loops, etc, you just declare what shuold happen in given target and/or configuration and for any other stuff, regular script language can be used (eg. python or bash). Why? Because we seen many projects where build scripts are more complicated than the code behind them.

### Another CMake then?
No, CMake is a build system generator which provides some sort of programming language to do so. It's like writing a python script which generates `Makefile`s, only that CMake syntax is far from being a programming language, and even if, why we need another?

### I could stick with `Makefile`s then
You can, but it's too low-level, `make` doesn't understand C++ project structure by itself, it doesn't know that your .cpp file include some .hpp, so if this .hpp changes, then .cpp should be rebuilt. You have to write such dependencies (nobody does that) or dependency generation support yourself.

### I heard Ninja is modern, cool and fast
It is, but its scripts are not supposed to be written by hand, see their description: "it is designed to have its input files generated by a higher-level build system". But CMake has a generator for it, so if for some reason you won't like pake, I would recommend CMake+Ninja.

## How to get it?
Because pake is a alpha quality software, the only official way of distributing it is to "build" it using waffle and put in inside your project repository. To simplyfy this, there is a shell script called `make_pake.sh` which generates `__build/pake.py` file which you can directly put and use in your project.

# Tutorial

## Starting a project
After putting pake.py somewhere suitable (for example in your project directory), create a pake module called `build.pake`. Note that only `.pake` extention is important, pake looks for all `.pake` files (we call them modules) inside your projects directory and you don't need to define them anywhere. Inside your build.pake file, put something like this:

```
target application my_app sources(main.cpp) # hi, I'm a comment!
```

this will define a target called my_app which is statically linked application which is built from `main.cpp`. To build it, just type `./pake.py my_app` or `./pake.py -a` if you want to build every target found in your tree. After building, your application will be placed into `__build/__default` directory.

## Adding more files to the project
Say, you want to add some new file into your project, you can write:

```
target application my_app sources(main.cpp additional_file.cpp)
```

this will compile `main.cpp` and `additional_file.cpp` and link them together. When your list gets too big, you can split it by escaping new line:

```
target application my_app \
    sources(main.cpp \
            additional_file.cpp)
```

or you can use variables:

```
append $sources main.cpp
append $sources additional_file.cpp

target application my_app sources($sources)
```

### Variable defining and dereferencing order
What is neat in pake variable system, is that you can define and reference the variables in any order you like, for example, you can do something like this:

```
target application my_app sources($all_sources yet_another_file.cpp)

append $sources $main_file
append $sources additional_file.cpp
append $main_file main.cpp
```

## Defining compiler flags to the target

Very often, there is a need for adding compiler switches to the target, there is a possibility to add them to the whole tree, but let us keep it simple for now. To add those, you just need to add `compiler_flags` parameter to target definition. You can add the directories in which compiler will look for header files, but this way is not very scalable, instead, use `include_dirs` for that:

```
append $sources main.cpp
append $sources additional_file.cpp

target application my_app \
    sources($sources) \
    compiler_flags(-std=c++14) \
    include_dirs(includes other_includes)
```

Hopefully, this example is self-explainatory.

## Bulding static libraries
Static library is just another type of target which pretty much behaves like the `application` target, only it builds an `.a` file which you can later link your application.

```
target static_library my_lib sources(library.cpp)
target application my_app link_with(my_lib) depends_on(my_lib)
```

Few things here, first, the new, `link_with` attribute, which doesn't really need to be explained, but why we need `depends_on`? It's because you can put inside link_with everything which understands your linker, include system wide libraries and `pake` has no way of knowing if given library should be builts or just passed quietly to the linker.

## More documentation

Stay tuned for more docus here... in the mean time, see the [wiki pages](https://github.com/podusowski/pake/wiki), there is some possibly outdated info there.

